<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Android 系统及应用启动流程 | whiplashz</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android 系统及应用启动流程</h1><a id="logo" href="/.">whiplashz</a><p class="description">今番良晤，豪兴不浅</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android 系统及应用启动流程</h1><div class="post-meta">2017-09-28<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、系统启动流程"><span class="toc-number">1.</span> <span class="toc-text">一、系统启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-init-进程"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 init 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-zygote"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 zygote</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-Native-层"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 Native 层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-Java-层"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 Java 层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-zygote-小结"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3 zygote 小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-SystemServer-启动过程"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 SystemServer 启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-启动-Binder-线程池"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 启动 Binder 线程池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-invokeStaticMain"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 invokeStaticMain</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-3-SystemSever-庐山真面目"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.3 SystemSever 庐山真面目</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-4-SystemServer-小结"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.3.4 SystemServer 小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-Launcher-启动"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 Launcher 启动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-1-Launcher-是什么"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 Launcher 是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-2-Launcher-启动流程"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2 Launcher 启动流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-3-加载应用图标"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.4.3 加载应用图标</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-系统启动流程总结"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 系统启动流程总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、应用启动流程"><span class="toc-number">2.</span> <span class="toc-text">二、应用启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-Application-基础理论"><span class="toc-number">2.0.1.</span> <span class="toc-text">2.1 Application 基础理论</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-应用启动过程"><span class="toc-number">2.0.2.</span> <span class="toc-text">2.2  应用启动过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-进程创建过程"><span class="toc-number">2.0.3.</span> <span class="toc-text">2.3 进程创建过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-绑定-Application"><span class="toc-number">2.0.4.</span> <span class="toc-text">2.4 绑定 Application</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-启动-Activity"><span class="toc-number">2.0.5.</span> <span class="toc-text">2.5 启动 Activity</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考资料"><span class="toc-number">2.1.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div><div class="post-content"><h3 id="一、系统启动流程"><a href="#一、系统启动流程" class="headerlink" title="一、系统启动流程"></a>一、系统启动流程</h3><p>Android 是一个基于 Linux 的系统，在按下电源键的那一刻，系统便启动了，那么在按下电源键之后，系统是如何启动的呢？</p>
<p>带着这个问题去探究可以知道，在底层中电源键按下后，引导芯片将开始从预定义的地方开始执行，加载引导程序到 RAM，进而执行引导程序，一般引导程序为针对主板和芯片的预定义程序，引导程序也是OEM厂商或者运营商加锁和限制的地方。</p>
<p>此外会初始化内核所需要的比如网络、内存等，此后将会启动内核，由于 Android 是基于 Linux 内核开发，所以整个的内核启动过程与 Linux 类似，尚未了解，不敢妄言。</p>
<p>在内核启动完成后，便会创建第一个进程，便是 init 进程。</p>
<h4 id="1-1-init-进程"><a href="#1-1-init-进程" class="headerlink" title="1.1 init 进程"></a>1.1 init 进程</h4><ul>
<li><p>在 Linux 启动之后，init 是用户空间里的第一个进程，确切的说 init 是 Linux 用户空间的第一个进程，但由于 Android 也是基于 Linux 内核，所以 init 也是 Android 系统中用户空间的第一个进程。</p>
</li>
<li><p>关于用户空间的概念：在 Linux 中，操作系统和驱动程序运行在<strong>内核空间</strong>，而应用程序运行在<strong>用户空间</strong>。两者之间不能简单的使用指针传递数据，因为 Linux 中使用的是虚拟内存机制，用户空间的数据可能被换出，所以当内核空间通过用户空间的指针时，可能会导致对应的数据丢失，所以会采用段页式地址映射机制。</p>
</li>
</ul>
<blockquote>
<p>ps：对于底层实现，由于知识储备不到位，所以很多一知半解，暂时不做分析 T_T..</p>
</blockquote>
<ul>
<li>init 进程负责创建系统中的几个关键进程，例如 log 系统，在此处要注意的是 zygote 进程，zygote 进程是整个 Java 世界的父进程，是后面 Android 系统启动流程所关注的重点。</li>
</ul>
<h4 id="1-2-zygote"><a href="#1-2-zygote" class="headerlink" title="1.2 zygote"></a>1.2 zygote</h4><h5 id="1-2-1-Native-层"><a href="#1-2-1-Native-层" class="headerlink" title="1.2.1 Native 层"></a>1.2.1 Native 层</h5><ul>
<li><p>在 Android 的系统架构层级划分中，一般分为四层：应用层、framework 层、Native 层、Linux 内核，在这四层中，其中应用层和 framework 层为 Java 实现，Native 为 C/C++ 的程序，而 zygote 就是所有 Java 进程的最初形态，zygote 这个词中文意思为“受精卵”，更可以形象的描述出 zygote 在整个 Java 世界的作用。<a id="more"></a></p>
</li>
<li><p>zygote 本身是一个 Native 的程序，源码中其入口在 </p>
</li>
</ul>
<blockquote>
<p>/platform_frameworks_base/cmds/app_process/App_main.cpp </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> ....</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">   </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序中可以看到， zygote 中的 main 函数中主要的功能均由 AppRuntime 完成，此后的活动也均由 AppRuntime 控制，所以在</p>
<blockquote>
<p>/platform_frameworks_base/core/jni/AndroidRuntime.cpp</p>
</blockquote>
<p>下找到 AndroidRuntime.cpp 文件，在其中看到 AppRuntime 重载了 onStarted、onZygoteInit 和 onExit 函数，由于 C++ 水平有限，所以仅对整个流程做一个梳理，不做具体实现分析，在整个的实现过程中，可以看到通过 startVm 调用 JNI 虚拟机的创建函数，在 startReg 中注册 JNI 函数，要知道 JNI 是连接 Java 和 Native 的桥梁，至此完成了虚拟机的创建，所谓虚拟机，在 Linux 下就是一个进程，Android 中每一个程序都有一个单独的进程，此后，通过 CallStaticVoidMethod 方法，将进入到 Java 层面。</p>
<h5 id="1-2-2-Java-层"><a href="#1-2-2-Java-层" class="headerlink" title="1.2.2 Java 层"></a>1.2.2 Java 层</h5><ul>
<li>以下内容所涉及到的源码文件：</li>
</ul>
<blockquote>
<p>/platform_frameworks_base/core/java/com/android/internal/os/</p>
<ul>
<li>ZygoteInit.java</li>
<li>Zygote.java</li>
<li>ZygoteConnection.java</li>
</ul>
</blockquote>
<blockquote>
<p>/platform_frameworks_base/core/java/android/net/LocalServerSocket.java<br>/system/core/libutils/Threads.cpp </p>
</blockquote>
<ul>
<li>作为 Java 世界的入口，通过 CallStaticVoidMethod 方法，最终将调用 ZygoteInit.java 的 main 函数：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    RuntimeInit.enableDdms(); <span class="comment">//开启DDMS功能</span></span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line">    <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">    String socketName = <span class="string">"zygote"</span>;</span><br><span class="line">    String abiList = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">            startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">            abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">            socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    registerZygoteSocket(socketName); <span class="comment">//为Zygote注册socket</span></span><br><span class="line">    preload(); <span class="comment">// 预加载类和资源</span></span><br><span class="line">    SamplingProfilerIntegration.writeZygoteSnapshot();</span><br><span class="line">    gcAndFinalize(); <span class="comment">//GC操作</span></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        startSystemServer(abiList, socketName);<span class="comment">//启动system_server</span></span><br><span class="line">    &#125;</span><br><span class="line">    runSelectLoop(abiList); <span class="comment">//进入循环模式</span></span><br><span class="line">    closeServerSocket();</span><br><span class="line">&#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">    caller.run(); <span class="comment">//启动system_server</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">    closeServerSocket();</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">........</span><br></pre></td></tr></table></figure>

<p>在上面的 main 函数里，几个主要的函数：</p>
<ul>
<li><strong>registerZygoteSocket  — 建立 IPC 通信服务端</strong></li>
</ul>
<p>由于 zygote 在与其他进程的通信中没有使用到 Binder 机制，而是采用了基于 AF_UNIX 类型的 Socket。</p>
<blockquote>
<p>Tips: （ 格式化套接口地址，相应的，地址族用来指明哪种类型的地址，常量AF_LOCAL（AF_UNIX）指明了地址将会按照本 地（UNIX）地址规则来格式化。常量AF_INET指明了地址将会符合IP地址规则。在一个地址族中，可以有多种类型 ）</p>
</blockquote>
<p>在这里，其实建立起的是一个服务端的 Socket ，进而可以在后续进行 IPC 通信。</p>
<ul>
<li><strong>preload — 预加载资源</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">(BootTimingsTraceLog bootTimingsTraceLog)</span> </span>&#123;</span><br><span class="line">.....</span><br><span class="line"><span class="comment">// 预加载位于/system/etc/preloaded-classes文件中的类</span></span><br><span class="line">preloadClasses();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预加载资源，包含drawable和color资源</span></span><br><span class="line">preloadResources();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预加载OpenGL</span></span><br><span class="line">preloadOpenGL();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过System.loadLibrary()方法，</span></span><br><span class="line"><span class="comment">//预加载"android","compiler_rt","jnigraphics"这3个共享库</span></span><br><span class="line">preloadSharedLibraries();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预加载 文本连接符资源</span></span><br><span class="line">preloadTextResources();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 preload() 方法中，preloadClasses() 会预加载的预加载类的列表在 /platform_frameworks_base/tools/preload 下，会进行加载时间的判断，当每个类的加载时间大于 1250 微秒的时候，就会被 zygote 预加载，所以在这里，也是一个优化系统启动速度的优化点，但是对技术的要求比较高~</p>
<p>同时这里还有一个小问题，就是当创建新的进程的时候，这些预加载的类和资源应该怎么操作呢？ 这里的处理方案采用了 copy on write 技术来实现，关于写时复制技术原理，暂不做细述。</p>
<ul>
<li><strong>startSystemServer — 启动 System_server</strong></li>
</ul>
<p>在这个方法中，通过设置参数和 fork 的方式，zygote 实现了一次分裂，分裂出一个 system_server 进程，即代码中对应 Zygote.forkSystemServer </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> capabilities = posixCapabilitiesAsBits(</span><br><span class="line">        ......</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// fork 参数准备</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">"--setuid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007"</span>,</span><br><span class="line">        <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">        <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">        <span class="string">"--runtime-args"</span>,</span><br><span class="line">        <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 用于解析参数，生成目标格式</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fork 子进程，运行 system_server</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入子进程system_server</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成system_server进程剩余的工作</span></span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>runSelectLoopMode — 开启服务端等待请求</strong></li>
</ul>
<p>在 zygote 从startSystemServer 返回之后，进入到下一个关键函数：runSelectLoopMode 。在 registerZygoteSocket 中我们注册了一个用户 IPC 通信的 Socket，但是当时并没有启用，而它真正启用的地方便是在 runSelectLoopMode 中，并且在这里 zygote 采用的是高效的 I/O 多路复用机制，保证在没有客户端请求和数据处理的时候休眠，在客户端请求时响应处理。</p>
<p><img src="/img/zygote_init.png" alt="zygote 启动流程图"></p>
<h5 id="1-2-3-zygote-小结"><a href="#1-2-3-zygote-小结" class="headerlink" title="1.2.3 zygote 小结"></a>1.2.3 zygote 小结</h5><p>虽然只是系统启动流程了解，但是到现在结合上面的流程图，总结一波在这里 zygote 究竟干了什么：</p>
<ol>
<li>创建 AppRuntime 对象并调用它的 start 方法，启动 zygote 进程，此后的操作活动由 AppRuntime 来控制。</li>
<li>调用 startVm 创建 Java 虚拟机，调用 startReg 来注册 JNI 函数。</li>
<li>通过 JNI 调用 com.android.internal.os.ZygoteInit下的 main 函数，初始化整个 Java 层。</li>
<li>通过 registerZygoteSocket 函数创建服务端 Socket，并通过 runSelectLoop 函数等待 ActivityManagerService 的请求来创建新的应用程序进程。</li>
<li>启动 SystemServer 进程。</li>
</ol>
<h4 id="1-3-SystemServer-启动过程"><a href="#1-3-SystemServer-启动过程" class="headerlink" title="1.3 SystemServer 启动过程"></a>1.3 SystemServer 启动过程</h4><p>在上一小节中的 ZygoteInit.java 中，调用了 startSystemServer 进程，SystemServer 进程的进程名实际为：system_server，通过前面内容可知，system_server 是zygote 通过 fork 诞生的，在执行 handleSystemServerProcess 方法的时候，发生了什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteConnection.Arguments parsedArgs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">           closeServerSocket();</span><br><span class="line">       ...</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cl = createSystemServerClassLoader(systemServerClasspath,</span><br><span class="line">                                               parsedArgs.targetSdkVersion);</span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合 copy on write 技术也可以明白，system_server 复制了 zygote 的地址空间，所以也会得到 zygote 所创建的 Socket， 但是对于 system_server 来说，这个 socket 并没有用处，所以用 closeServerSocket 来关闭。</p>
<p>RuntimeInit.zygoteInit() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line">     Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</span><br><span class="line">     redirectLogStreams();</span><br><span class="line">     commonInit();</span><br><span class="line">     nativeZygoteInit();</span><br><span class="line">     applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>通过 native 和 application 两个 init 函数来实现 system_server 的初始化。</p>
<p>另外，在程序中，可以发现 zygote 和 system_server 是同生死的，当 system_server 挂掉，那么 zygote 也会把自己干掉。</p>
<h5 id="1-3-1-启动-Binder-线程池"><a href="#1-3-1-启动-Binder-线程池" class="headerlink" title="1.3.1 启动 Binder 线程池"></a>1.3.1 启动 Binder 线程池</h5><p>顺着 nativeZygoteInit() 方法看下去，会发现在</p>
<blockquote>
<p>/platform_frameworks_base/cmds/app_process/app_main.cpp </p>
</blockquote>
<p>中调用如下的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">virtual <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</span><br><span class="line">    proc-&gt;startThreadPool(); <span class="comment">// 启动 线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注释位置便是启动了一个 Binder 的线程池，用于和其他进程进行通信，可以发现 nativeZygoteInit() 主要便是启动 Binder 线程池。</p>
<h5 id="1-3-2-invokeStaticMain"><a href="#1-3-2-invokeStaticMain" class="headerlink" title="1.3.2 invokeStaticMain"></a>1.3.2 invokeStaticMain</h5><p>回到 RuntimeInit.java，可以看到调用了 applicationInit 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">        ...</span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中调用了 invokStaticMian 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过反射返回的 cl (SystemServer类)</span></span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[]<span class="class">.<span class="keyword">class</span> &#125;)</span>;<span class="comment">// main</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//main函数传入到 MethodAndArgsCaller 异常中并抛出该异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>截获的 MethodAndArgsCaller 异常在 ZygoteInit.java 的 main 函数中。</p>
<h5 id="1-3-3-SystemSever-庐山真面目"><a href="#1-3-3-SystemSever-庐山真面目" class="headerlink" title="1.3.3 SystemSever 庐山真面目"></a>1.3.3 SystemSever 庐山真面目</h5><blockquote>
<p>/platform_frameworks_base/services/java/com/android/server/SystemServer.java</p>
</blockquote>
<p>zygote 分裂产生 SystemServer ，其实就是调用 com.android.server.SystemServer 的 main 函数， main 函数代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run 函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        System.loadLibrary(<span class="string">"android_servers"</span>);<span class="comment">//加载 libandroid_servers.so</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 创建 SystemServiceManager</span></span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">        LocalServices.addService(SystemServiceManager<span class="class">.<span class="keyword">class</span>, <span class="title">mSystemServiceManager</span>)</span>;</span><br><span class="line">    ...    </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, <span class="string">"StartServices"</span>);</span><br><span class="line">        <span class="comment">// 启动各式各样的服务</span></span><br><span class="line">        startBootstrapServices();<span class="comment">// 引导</span></span><br><span class="line">        startCoreServices(); <span class="comment">// 核心</span></span><br><span class="line">        startOtherServices(); <span class="comment">// 其他</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">"System"</span>, <span class="string">"******************************************"</span>);</span><br><span class="line">        Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting system services"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中可以看到把 Service 分为 引导、核心、其他三大类，可以对服务进行管理等操作，常见的服务比如：ActivityManagerService、PowerManagerService、Installer 等，具体启动实现细节不做细节描述，主体为创建 ServiceManager ，通过系统 C/S 架构中的 Binder 进行通信，启动各种系统服务并对其i进行管理。</p>
<h5 id="1-3-4-SystemServer-小结"><a href="#1-3-4-SystemServer-小结" class="headerlink" title="1.3.4 SystemServer 小结"></a>1.3.4 SystemServer 小结</h5><p>SystemServer 主要工作为下面三个方面：</p>
<ol>
<li>启动 Binder 线程池</li>
<li>创建SystemServiceManager用于对系统的服务进行创建、启动和生命周期管理</li>
<li>启动各种系统服务</li>
</ol>
<h4 id="1-4-Launcher-启动"><a href="#1-4-Launcher-启动" class="headerlink" title="1.4 Launcher 启动"></a>1.4 Launcher 启动</h4><h5 id="1-4-1-Launcher-是什么"><a href="#1-4-1-Launcher-是什么" class="headerlink" title="1.4.1 Launcher 是什么"></a>1.4.1 Launcher 是什么</h5><p> Android 系统启动的最后一步，是加载 Launcher 应用程序，Launcher 是一个桌面应用，用来展示已经安装的应用程序入口，Launcher 在启动过程中会请 求PackageManagerService 返回系统中已经安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，这样用户可以通过点击这些快捷图标来启动相应的应用程序。</p>
<h5 id="1-4-2-Launcher-启动流程"><a href="#1-4-2-Launcher-启动流程" class="headerlink" title="1.4.2 Launcher 启动流程"></a>1.4.2 Launcher 启动流程</h5><p>在上面的 startOtherService 方法中，有这样几行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"Making services ready"</span>);</span><br><span class="line">                mSystemServiceManager.startBootPhase(</span><br><span class="line">                        SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br></pre></td></tr></table></figure>

<p>可以看到，在 AMS 中会调用 systemReady 方法：</p>
<blockquote>
<p>/platform_frameworks_base/services/core/java/com/android/server/am/ActivityManagerService.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           ...</span><br><span class="line">            mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">            mUserController.sendUserSwitchBroadcastsLocked(-<span class="number">1</span>, currentUserId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>systemReady  方法中调用了 ActivityStackSupervisor 的 resumeFocusedStackTopActivityLocked 方法，其中 ActivityStackSupervisor  是 Activity 堆栈相关，在 resumeFocusedStackTopActivityLocked  会调用 resumeTopActivityInnerLocked 方法，进而调用 ActivityManagerService 的 startHomeActivityLocked 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startHomeActivityLocked</span><span class="params">(<span class="keyword">int</span> userId, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 系统运行模式选择：非工厂模式、低级工厂模式和高级工厂模式</span></span><br><span class="line">  	<span class="comment">// 这里是低级工厂模式</span></span><br><span class="line">     <span class="keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL</span><br><span class="line">             &amp;&amp; mTopAction == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  	<span class="comment">// Intent</span></span><br><span class="line">     Intent intent = getHomeIntent();</span><br><span class="line">     ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</span><br><span class="line">     <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">         intent.setComponent(<span class="keyword">new</span> ComponentName(aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line">         aInfo = <span class="keyword">new</span> ActivityInfo(aInfo);</span><br><span class="line">         aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line">         ProcessRecord app = getProcessRecordLocked(aInfo.processName,</span><br><span class="line">                 aInfo.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//判断符合 Action 为Intent.ACTION_MAIN，</span></span><br><span class="line">       <span class="comment">// Category为Intent.CATEGORY_HOME 的应用程序是否已经启动</span></span><br><span class="line">       <span class="comment">// 如果没启动则调用注释4的方法启动该应用程序。</span></span><br><span class="line">		Intent.ACTION_MAIN，Category为Intent.CATEGORY_HOME。</span><br><span class="line">         <span class="keyword">if</span> (app == <span class="keyword">null</span> || app.instrumentationClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">             intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">             mActivityStarter.startHomeActivityLocked(intent, aInfo, reason);<span class="comment">//4</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         Slog.wtf(TAG, <span class="string">"No home screen found for "</span> + intent, <span class="keyword">new</span> Throwable());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>上述代码中 Intent 所启动的这个应用程序就是 Launcher，因为 Launcher 的 Manifest 文件中的intent-filter标签匹配了Action为 Intent.ACTION_MAIN，Category 为 Intent.CATEGORY_HOME。</p>
<h5 id="1-4-3-加载应用图标"><a href="#1-4-3-加载应用图标" class="headerlink" title="1.4.3 加载应用图标"></a>1.4.3 加载应用图标</h5><p>Launcher 会根据自身的程序设计进行扫描，将已经安装的程序文件的图标显示在桌面，从而实现我们所见到的的 Launcher ，即整个桌面应用。</p>
<h4 id="1-5-系统启动流程总结"><a href="#1-5-系统启动流程总结" class="headerlink" title="1.5 系统启动流程总结"></a>1.5 系统启动流程总结</h4><p>通过上述的分析，对整个 Android 的系统启动流程总结如下：</p>
<ol>
<li><p>按下电源键  =》引导程序 Bootloader 加载到 RAM  并开始执行。</p>
</li>
<li><p>内核启动，加载驱动、设置缓存，完成系统设置等 =》启动 init 进程</p>
</li>
<li><p>init 进程初始化 =》启动 Zygote 进程</p>
</li>
<li><p>创建 Java VM 、注册 JNI 、创建服务端 Socket 、启动 SystemServer</p>
</li>
<li><p>启动 Binder 线程池和 SystemServiceManager ，并且启动各种系统服务</p>
</li>
<li><p>SystemServer 进程=》启动 ActivityManagerService =》启动Launcher，Launcher 将已安装应用的快捷图标显示到界面上。</p>
</li>
<li><p>完成系统启动流程</p>
<p>对上述过程进行流程图绘制，总结如下：</p>
</li>
</ol>
<h3 id="二、应用启动流程"><a href="#二、应用启动流程" class="headerlink" title="二、应用启动流程"></a>二、应用启动流程</h3><h5 id="2-1-Application-基础理论"><a href="#2-1-Application-基础理论" class="headerlink" title="2.1 Application 基础理论"></a>2.1 Application 基础理论</h5><p>要想清楚 APP 的启动流程，必须要对其理论知识清晰明确，所以对 Android Application 的基础理论，暂列如下：</p>
<ol>
<li><p>Android APP 每个都有自己独立的空间，运行在一个单独的进程，拥有唯一的一个 VM 和 ID。</p>
</li>
<li><p>Android APP 拥有很多不同的组件，相互关联，所以程序没有一个类似程序入口的 main() 方法。</p>
</li>
<li><p>Application 的组件分别为：Activity、Service、Broadcast Receiver、Content Provider。</p>
</li>
</ol>
<p>在 Android 中的进程和 Linux 蕾丝，默认情况下每个 APK 运行在自己的 Linux 进程中，此外，在整个的进程中有一个默认的线程——UI 线程，即主线程，在主线程中可以拿到一个 Looper 实例，通过 Looper.loop() 不断的从 Message 队列中取出 Message 来进行消息传递并作对应的处理。</p>
<p>所以，问题来了，该进程是什么时候启动的呢？</p>
<p>从意图的角度出发，进程在被调用的时候启用，当用户点击图标启动或者通过其他组件来调用 APK 里面的内容时，如果 APK 不属于运行状态，那么系统会为该应用创建一个新的进程来启动，所以，进程，归根到底为在需要的时候才会创建。</p>
<p>回顾一下上面的 Android 系统启动流程， bootloader 启动内核和 init 进程，init进程创建 zygote，在这里补充一点，就是在 init 进程中，会分裂出更多名为 “daemons” 的守护进程，为底层的 Linux 进程来处理底层硬件相关的接口。然后就是 zygote 的一系列操作，继而创建 SystemServer ，然后启动所有的系统核心服务，再这里，就会有一个 Service 被启动，就是 ActivityManagerService ，然后会加载 Launcher ，进入到桌面。</p>
<h5 id="2-2-应用启动过程"><a href="#2-2-应用启动过程" class="headerlink" title="2.2  应用启动过程"></a>2.2  应用启动过程</h5><p>在桌面上，用户点击到某一个应用的时候，点击事件会通过 startActivity(Intent) 方法启动一个 Activity，那么点击事件发生后，是如何通知系统创建一个新的 Activity 呢，这里用到的又是 Android 中的进程通信，就是 Binder IPC 机制，最终会调用到 ActivityManagerService ，该 Service 会执行以下几步操作：</p>
<ul>
<li>通过 PackageManager 的 resolveIntent() 收集这个 intent 的指向信息。</li>
<li>将指向信息存储到一个 intent 中。</li>
<li>通过 grantUriPermissionLocked() 方法验证用户是否有足够的权限调用 intent 指向的目标 Activity</li>
<li>有权限， AMS 会检查并创建一个新的 task 来启动 Activity </li>
<li>检查该进程的 PricessRecord 是否存在，如果为 null AMS 会创建新的进程来实例化 Activity</li>
<li>执行 Activity 的生命周期 =》应用启动完成</li>
</ul>
<p><strong>启动过程图示：</strong></p>
<p><img src="/img/app_start.png" alt="应用启动过程图示"></p>
<h5 id="2-3-进程创建过程"><a href="#2-3-进程创建过程" class="headerlink" title="2.3 进程创建过程"></a>2.3 进程创建过程</h5><p>ActivityManagerService 调用 startProcessLocked() 方法来创建新的进程，在该方法中，会通过 socket 将参数传递给 zygote 进程，zygote 分裂，调用 ZygoteInit.man() 方法来实例化 ActivityThread 并最终返回新的进程 pid；随后 ActivityThread 会一次调用 Looper.prepareLoop() 和 Looper.loop() 来开启消息循环。流程图如下（<a href="http://www.jianshu.com/p/a5532ecc8377" target="_blank" rel="noopener">图片来源</a>）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/851999-b6b5dacf9d1488f9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="process creation"></p>
<h5 id="2-4-绑定-Application"><a href="#2-4-绑定-Application" class="headerlink" title="2.4 绑定 Application"></a>2.4 绑定 Application</h5><p>在进程创建完成后，需要将进程和 Application 进行绑定，通过调用 ActivityThread 对象中的 bindApplication() 方法来完成，发送一个 BIND_APPLICATION 消息到 MessageQueue 中，进而通过 handlerBindApplication() 方法处理该消息，调用 makeApplication() 方法来加载 App 的 classes 到内存中。</p>
<p>流程图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/851999-32893aaf343caeac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" alt="bind application"></p>
<h5 id="2-5-启动-Activity"><a href="#2-5-启动-Activity" class="headerlink" title="2.5 启动 Activity"></a>2.5 启动 Activity</h5><p>经过上述步骤，系统中便存在了该 Application 的进程，后面的调用顺序为从一个已经存在的进程中启动一个新进程的 Activity了。</p>
<p>调用方法为 realStartActivity() 它会调用 application 对象中的 sheduleLaunchActivity 发送一个 LAUNCH_AVTIVITY 的消息到消息队列中，通过 handleLaunchActivity() 来处理该消息。</p>
<p>至此，应用启动流程结束，进入到应用的生命周期。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>《深入理解 Android 系统 卷 I》</li>
<li>《Android 进阶之光》</li>
<li><a href="http://gityuan.com/" target="_blank" rel="noopener">Gityuan 技术博客</a></li>
<li><a href="http://www.jianshu.com/p/a5532ecc8377" target="_blank" rel="noopener">[译]Android Application启动流程分析</a></li>
<li><a href="http://multi-core-dump.blogspot.com/2010/04/android-application-launch.html" target="_blank" rel="noopener">Android Application Launch part 1</a></li>
<li><a href="http://multi-core-dump.blogspot.com/2010/04/android-application-launch-part-2.html" target="_blank" rel="noopener">Android Application Launch part 2</a></li>
</ul>
</div><div class="tags"><a href="/tags/Android/"><i class="fa fa-tag"></i>Android</a><a href="/tags/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"><i class="fa fa-tag"></i>系统启动流程</a></div><div class="post-nav"><a class="pre" href="/2017/10/05/android_activity/">Activity 生命周期和启动模式</a><a class="next" href="/2017/07/30/%E5%86%8D%E4%B8%B4%E7%8F%A0%E4%B8%89%E8%A7%92/">再临珠三角</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Emotion/">Emotion</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Technology/">Technology</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Translate/">Translate</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/diary/" style="font-size: 15px;">diary</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/MVC/" style="font-size: 15px;">MVC</a> <a href="/tags/MVP/" style="font-size: 15px;">MVP</a> <a href="/tags/Alpha-beta/" style="font-size: 15px;">Alpha-beta</a> <a href="/tags/Activity/" style="font-size: 15px;">Activity</a> <a href="/tags/Stability/" style="font-size: 15px;">Stability</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" style="font-size: 15px;">系统启动流程</a> <a href="/tags/View/" style="font-size: 15px;">View</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 15px;">正则表达式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/07/flutter-5-reasons-why-you-may-love-it/">Flutter — 五个你会爱上它的原因</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/01/confusion-subject-observable-observer-android-rxjava2-hell-part8/">Subject 和 Observable + Observer 的混淆指北[ Android RxJava2 ] ( 这什么鬼系列 ) 第八话</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/10/Java_JVM_classloader/">Java 虚拟机类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/05/Java_reference/">Java 引用类型分析与总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/04/Java_input_output_stream/">Java 输入输出流</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/03/Java_data%20structure_Hashmap/">Java 数据结构实现原理之 HashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/21/Java_data%20structure_ArrayList/">Java 数据结构实现原理之 ArrayList</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/02/Java_BasicKnowledge/">Java 基础知识点梳理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/17/android_stability/">Android 系统稳定性问题相关梳理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/android_view/">View 的事件体系及工作原理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">whiplashz.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=0.0.0"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>